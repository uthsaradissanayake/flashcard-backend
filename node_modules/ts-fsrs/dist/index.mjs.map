{"version":3,"file":"index.mjs","sources":["../src/fsrs/models.ts","../src/fsrs/help.ts","../src/fsrs/scheduler.ts","../src/fsrs/default.ts","../src/fsrs/algorithm.ts","../src/fsrs/fsrs.ts"],"sourcesContent":["export type StateType = \"New\" | \"Learning\" | \"Review\" | \"Relearning\";\n\nexport enum State {\n  New = 0,\n  Learning = 1,\n  Review = 2,\n  Relearning = 3,\n}\n\nexport type RatingType = \"Manual\" | \"Again\" | \"Hard\" | \"Good\" | \"Easy\";\n\nexport enum Rating {\n  Manual = 0,\n  Again = 1,\n  Hard = 2,\n  Good = 3,\n  Easy = 4,\n}\n\ntype ExcludeManual<T> = Exclude<T, Rating.Manual>;\n\nexport type Grade = ExcludeManual<Rating>;\n\nexport interface ReviewLog {\n  rating: Rating; // Rating of the review (Again, Hard, Good, Easy)\n  state: State; // State of the review (New, Learning, Review, Relearning)\n  due: Date; // Date of the last scheduling\n  stability: number; // Memory stability during the review\n  difficulty: number; // Difficulty of the card during the review\n  elapsed_days: number; // Number of days elapsed since the last review\n  last_elapsed_days: number; // Number of days between the last two reviews\n  scheduled_days: number; // Number of days until the next review\n  review: Date; // Date of the review\n}\n\nexport type RecordLogItem = {\n  card: Card;\n  log: ReviewLog;\n};\nexport type RecordLog = {\n  [key in Grade]: RecordLogItem;\n};\n\nexport interface Card {\n  due: Date; // Due date\n  stability: number; // Stability\n  difficulty: number; // Difficulty level\n  elapsed_days: number; // Number of days elapsed\n  scheduled_days: number; // Number of days scheduled\n  reps: number; // Repetition count\n  lapses: number; // Number of lapses or mistakes\n  state: State; // Card's state (New, Learning, Review, Relearning)\n  last_review?: Date; // Date of the last review (optional)\n}\n\nexport interface CardInput extends Omit<Card, \"state\" | \"due\" | \"last_review\"> {\n  state: StateType | State; // Card's state (New, Learning, Review, Relearning)\n  due: DateInput; // Due date\n  last_review?: DateInput | null; // Date of the last review (optional)\n}\n\nexport type DateInput = Date | number | string;\n\nexport interface ReviewLogInput\n  extends Omit<ReviewLog, \"rating\" | \"state\" | \"due\" | \"review\"> {\n  rating: RatingType | Rating; // Rating of the review (Again, Hard, Good, Easy)\n  state: StateType | State; // Card's state (New, Learning, Review, Relearning)\n  due: DateInput; // Due date\n  review: DateInput; // Date of the last review\n}\n\nexport interface FSRSParameters {\n  request_retention: number;\n  maximum_interval: number;\n  w: number[];\n  enable_fuzz: boolean;\n}\n\nexport type RescheduleOptions = {\n  enable_fuzz?: boolean;\n  dateHandler?: (date: Date) => DateInput;\n};\n","import type { int, unit } from \"./type\";\nimport type { DateInput, Grade } from \"./models\";\nimport { Rating, State } from \"./models\";\n\ndeclare global {\n  export interface Date {\n    scheduler(t: int, isDay?: boolean): Date;\n\n    diff(pre: Date, unit: unit): int;\n\n    format(): string;\n\n    dueFormat(last_review: Date, unit?: boolean, timeUnit?: string[]): string;\n  }\n}\n\nDate.prototype.scheduler = function (t: int, isDay?: boolean): Date {\n  return date_scheduler(this, t, isDay);\n};\n\n/**\n * 当前时间与之前的时间差值\n * @param pre 比当前时间还要之前\n * @param unit 单位: days | minutes\n */\nDate.prototype.diff = function (pre: Date, unit: unit): int {\n  return date_diff(this, pre, unit) as int;\n};\n\nDate.prototype.format = function (): string {\n  return formatDate(this);\n};\n\nDate.prototype.dueFormat = function (\n  last_review: Date,\n  unit?: boolean,\n  timeUnit?: string[],\n) {\n  return show_diff_message(this, last_review, unit, timeUnit);\n};\n\n/**\n * 计算日期和时间的偏移，并返回一个新的日期对象。\n * @param now 当前日期和时间\n * @param t 时间偏移量，当 isDay 为 true 时表示天数，为 false 时表示分钟\n * @param isDay （可选）是否按天数单位进行偏移，默认为 false，表示按分钟单位计算偏移\n * @returns 偏移后的日期和时间对象\n */\nexport function date_scheduler(\n  now: DateInput,\n  t: number,\n  isDay?: boolean,\n): Date {\n  return new Date(\n    isDay\n      ? fixDate(now).getTime() + t * 24 * 60 * 60 * 1000\n      : fixDate(now).getTime() + t * 60 * 1000,\n  );\n}\n\nexport function date_diff(now: DateInput, pre: DateInput, unit: unit): number {\n  if (!now || !pre) {\n    throw new Error(\"Invalid date\");\n  }\n  const diff = fixDate(now).getTime() - fixDate(pre).getTime();\n  let r = 0;\n  switch (unit) {\n    case \"days\":\n      r = Math.floor(diff / (24 * 60 * 60 * 1000));\n      break;\n    case \"minutes\":\n      r = Math.floor(diff / (60 * 1000));\n      break;\n  }\n  return r;\n}\n\nexport function formatDate(dateInput: DateInput): string {\n  const date = fixDate(dateInput);\n  const year: number = date.getFullYear();\n  const month: number = date.getMonth() + 1;\n  const day: number = date.getDate();\n  const hours: number = date.getHours();\n  const minutes: number = date.getMinutes();\n  const seconds: number = date.getSeconds();\n\n  return `${year}-${padZero(month)}-${padZero(day)} ${padZero(hours)}:${padZero(\n    minutes,\n  )}:${padZero(seconds)}`;\n}\n\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`;\n}\n\nconst TIMEUNIT = [60, 60, 24, 31, 12];\nconst TIMEUNITFORMAT = [\"second\", \"min\", \"hour\", \"day\", \"month\", \"year\"];\n\nexport function show_diff_message(\n  due: DateInput,\n  last_review: DateInput,\n  unit?: boolean,\n  timeUnit: string[] = TIMEUNITFORMAT,\n): string {\n  due = fixDate(due);\n  last_review = fixDate(last_review);\n  if (timeUnit.length !== TIMEUNITFORMAT.length) {\n    timeUnit = TIMEUNITFORMAT;\n  }\n  let diff = due.getTime() - last_review.getTime();\n  let i;\n  diff /= 1000;\n  for (i = 0; i < TIMEUNIT.length; i++) {\n    if (diff < TIMEUNIT[i]) {\n      break;\n    } else {\n      diff /= TIMEUNIT[i];\n    }\n  }\n  return `${Math.floor(diff)}${unit ? timeUnit[i] : \"\"}`;\n}\n\nexport function fixDate(value: unknown) {\n  if (typeof value === \"object\" && value instanceof Date) {\n    return value;\n  } else if (typeof value === \"string\") {\n    const timestamp = Date.parse(value);\n    if (!isNaN(timestamp)) {\n      return new Date(timestamp);\n    } else {\n      throw new Error(`Invalid date:[${value}]`);\n    }\n  } else if (typeof value === \"number\") {\n    return new Date(value);\n  }\n  throw new Error(`Invalid date:[${value}]`);\n}\n\nexport function fixState(value: unknown): State {\n  if (typeof value === \"string\") {\n    const firstLetter = value.charAt(0).toUpperCase();\n    const restOfString = value.slice(1).toLowerCase();\n    const ret = State[`${firstLetter}${restOfString}` as keyof typeof State];\n    if (ret === undefined) {\n      throw new Error(`Invalid state:[${value}]`);\n    }\n    return ret;\n  } else if (typeof value === \"number\") {\n    return value as State;\n  }\n  throw new Error(`Invalid state:[${value}]`);\n}\n\nexport function fixRating(value: unknown): Rating {\n  if (typeof value === \"string\") {\n    const firstLetter = value.charAt(0).toUpperCase();\n    const restOfString = value.slice(1).toLowerCase();\n    const ret = Rating[`${firstLetter}${restOfString}` as keyof typeof Rating];\n    if (ret === undefined) {\n      throw new Error(`Invalid rating:[${value}]`);\n    }\n    return ret;\n  } else if (typeof value === \"number\") {\n    return value as Rating;\n  }\n  throw new Error(`Invalid rating:[${value}]`);\n}\n\nexport const Grades: Readonly<Grade[]> = [\n  Rating.Again,\n  Rating.Hard,\n  Rating.Good,\n  Rating.Easy,\n] as const;\n\nconst FUZZ_RANGES = [\n  {\n    start: 2.5,\n    end: 7.0,\n    factor: 0.15,\n  },\n  {\n    start: 7.0,\n    end: 20.0,\n    factor: 0.1,\n  },\n  {\n    start: 20.0,\n    end: Infinity,\n    factor: 0.05,\n  },\n] as const;\n\nexport function get_fuzz_range(\n  interval: number,\n  elapsed_days: number,\n  maximum_interval: number,\n) {\n  let delta = 1.0;\n  for (const range of FUZZ_RANGES) {\n    delta +=\n      range.factor * Math.max(Math.min(interval, range.end) - range.start, 0.0);\n  }\n  interval = Math.min(interval, maximum_interval);\n  let min_ivl = Math.max(2, Math.round(interval - delta));\n  const max_ivl = Math.min(Math.round(interval + delta), maximum_interval);\n  if (interval > elapsed_days) {\n    min_ivl = Math.max(min_ivl, elapsed_days + 1);\n  }\n  min_ivl = Math.min(min_ivl, max_ivl);\n  return { min_ivl, max_ivl };\n}\n","import { Card, Rating, RecordLog, State } from \"./models\";\nimport { date_scheduler } from \"./help\";\n\nexport class SchedulingCard {\n  again: Card;\n  hard: Card;\n  good: Card;\n  easy: Card;\n  last_review: Date;\n  last_elapsed_days: number;\n\n  private copy(card: Card): Card {\n    return {\n      ...card,\n    };\n  }\n\n  constructor(card: Card, now: Date) {\n    this.last_review = card.last_review || card.due;\n    this.last_elapsed_days = card.elapsed_days;\n    card.elapsed_days =\n      card.state === State.New ? 0 : now.diff(card.last_review as Date, \"days\"); //相距时间\n    card.last_review = now; // 上次复习时间\n    card.reps += 1;\n    this.again = this.copy(card);\n    this.hard = this.copy(card);\n    this.good = this.copy(card);\n    this.easy = this.copy(card);\n  }\n\n  update_state(state: State) {\n    if (state === State.New) {\n      this.again.state = State.Learning;\n      this.hard.state = State.Learning;\n      this.good.state = State.Learning;\n      this.easy.state = State.Review;\n    } else if (state === State.Learning || state === State.Relearning) {\n      this.again.state = state;\n      this.hard.state = state;\n      this.good.state = State.Review;\n      this.easy.state = State.Review;\n    } else if (state === State.Review) {\n      this.again.state = State.Relearning;\n      this.hard.state = State.Review;\n      this.good.state = State.Review;\n      this.easy.state = State.Review;\n      this.again.lapses += 1;\n    }\n    return this;\n  }\n\n  schedule(\n    now: Date,\n    hard_interval: number,\n    good_interval: number,\n    easy_interval: number,\n  ): SchedulingCard {\n    this.again.scheduled_days = 0;\n    this.hard.scheduled_days = hard_interval;\n    this.good.scheduled_days = good_interval;\n    this.easy.scheduled_days = easy_interval;\n    this.again.due = date_scheduler(now, 5);\n    this.hard.due =\n      hard_interval > 0\n        ? date_scheduler(now, hard_interval, true)\n        : date_scheduler(now, 10);\n    this.good.due = date_scheduler(now, good_interval, true);\n    this.easy.due = date_scheduler(now, easy_interval, true);\n    return this;\n  }\n\n  record_log(card: Card, now: Date): RecordLog {\n    return {\n      [Rating.Again]: {\n        card: this.again,\n        log: {\n          rating: Rating.Again,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Hard]: {\n        card: this.hard,\n        log: {\n          rating: Rating.Hard,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Good]: {\n        card: this.good,\n        log: {\n          rating: Rating.Good,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n      [Rating.Easy]: {\n        card: this.easy,\n        log: {\n          rating: Rating.Easy,\n          state: card.state,\n          due: this.last_review,\n          stability: card.stability,\n          difficulty: card.difficulty,\n          elapsed_days: card.elapsed_days,\n          last_elapsed_days: this.last_elapsed_days,\n          scheduled_days: card.scheduled_days,\n          review: now,\n        },\n      },\n    };\n  }\n}\n","import { Card, DateInput, FSRSParameters, State } from \"./models\";\nimport { fixDate } from \"./help\";\n\nexport const default_request_retention = 0.9;\nexport const default_maximum_interval = 36500;\nexport const default_w = [\n  0.5701, 1.4436, 4.1386, 10.9355, 5.1443, 1.2006, 0.8627, 0.0362, 1.629,\n  0.1342, 1.0166, 2.1174, 0.0839, 0.3204, 1.4676, 0.219, 2.8237,\n];\nexport const default_enable_fuzz = false;\n\nexport const FSRSVersion: string = \"3.5.7\";\n\nexport const generatorParameters = (\n  props?: Partial<FSRSParameters>,\n): FSRSParameters => {\n  return {\n    request_retention: props?.request_retention || default_request_retention,\n    maximum_interval: props?.maximum_interval || default_maximum_interval,\n    w: props?.w || default_w,\n    enable_fuzz: props?.enable_fuzz || default_enable_fuzz,\n  };\n};\n\n/**\n * Create an empty card\n * @param now Current time\n * @param afterHandler Convert the result to another type. (Optional)\n * @example\n * ```\n * const card: Card = createEmptyCard(new Date());\n * ```\n * @example\n * ```\n * interface CardUnChecked\n *   extends Omit<Card, \"due\" | \"last_review\" | \"state\"> {\n *   cid: string;\n *   due: Date | number;\n *   last_review: Date | null | number;\n *   state: StateType;\n * }\n *\n * function cardAfterHandler(card: Card) {\n *      return {\n *       ...card,\n *       cid: \"test001\",\n *       state: State[card.state],\n *       last_review: card.last_review ?? null,\n *     } as CardUnChecked;\n * }\n *\n * const card: CardUnChecked = createEmptyCard(new Date(), cardAfterHandler);\n * ```\n */\nexport function createEmptyCard<R = Card>(\n  now?: DateInput,\n  afterHandler?: (card: Card) => R,\n): R {\n  const emptyCard: Card = {\n    due: now ? fixDate(now) : new Date(),\n    stability: 0,\n    difficulty: 0,\n    elapsed_days: 0,\n    scheduled_days: 0,\n    reps: 0,\n    lapses: 0,\n    state: State.New,\n    last_review: undefined,\n  };\n  if (afterHandler && typeof afterHandler === \"function\") {\n    return afterHandler(emptyCard);\n  } else {\n    return emptyCard as R;\n  }\n}\n","import pseudorandom from \"seedrandom\";\nimport { generatorParameters } from \"./default\";\nimport { SchedulingCard } from \"./scheduler\";\nimport { FSRSParameters, Grade, Rating } from \"./models\";\nimport type { int } from \"./type\";\nimport { get_fuzz_range } from \"./help\";\n\n/**\n * @default DECAY = -0.5\n */\nexport const DECAY: number = -0.5;\n/**\n * FACTOR = Math.pow(0.9, 1 / DECAY) - 1= 19 / 81\n *\n * $$\\text{FACTOR} = \\frac{19}{81}$$\n * @default FACTOR = 19 / 81\n */\nexport const FACTOR: number = 19 / 81;\n\n/**\n * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n */\nexport class FSRSAlgorithm {\n  protected param!: FSRSParameters;\n  protected intervalModifier!: number;\n  protected seed?: string;\n\n  constructor(params: Partial<FSRSParameters>) {\n    this.param = new Proxy(\n      generatorParameters(params),\n      this.params_handler_proxy(),\n    );\n    this.intervalModifier = this.calculate_interval_modifier(\n      this.param.request_retention,\n    );\n  }\n\n  get interval_modifier(): number {\n    return this.intervalModifier;\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n   *\n   * The formula used is: $$I(r,s) = (r^{\\frac{1}{DECAY}} - 1) / FACTOR \\times s$$\n   * @param request_retention 0<request_retention<=1,Requested retention rate\n   * @throws {Error} Requested retention rate should be in the range (0,1]\n   */\n  calculate_interval_modifier(request_retention: number): number {\n    if (request_retention <= 0 || request_retention > 1) {\n      throw new Error(\"Requested retention rate should be in the range (0,1]\");\n    }\n    return +((Math.pow(request_retention, 1 / DECAY) - 1) / FACTOR).toFixed(8);\n  }\n\n  /**\n   * Get the parameters of the algorithm.\n   */\n  get parameters(): FSRSParameters {\n    return this.param;\n  }\n\n  /**\n   * Set the parameters of the algorithm.\n   * @param params Partial<FSRSParameters>\n   */\n  set parameters(params: Partial<FSRSParameters>) {\n    this.update_parameters(params);\n  }\n\n  private params_handler_proxy(): ProxyHandler<FSRSParameters> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const _this: FSRSAlgorithm = this;\n    return {\n      set: function (target, prop, value) {\n        if (prop === \"request_retention\" && Number.isFinite(value)) {\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(value),\n          );\n        }\n        // @ts-ignore\n        target[prop] = value;\n        return true;\n      },\n    };\n  }\n\n  private update_parameters(params: Partial<FSRSParameters>): void {\n    const _params = generatorParameters(params);\n    for (const key in _params) {\n      if (key in this.param) {\n        const paramKey = key as keyof FSRSParameters;\n        this.param[paramKey] = _params[paramKey] as never;\n      }\n    }\n  }\n\n  init_ds(s: SchedulingCard): void {\n    s.again.difficulty = this.init_difficulty(Rating.Again);\n    s.again.stability = this.init_stability(Rating.Again);\n    s.hard.difficulty = this.init_difficulty(Rating.Hard);\n    s.hard.stability = this.init_stability(Rating.Hard);\n    s.good.difficulty = this.init_difficulty(Rating.Good);\n    s.good.stability = this.init_stability(Rating.Good);\n    s.easy.difficulty = this.init_difficulty(Rating.Easy);\n    s.easy.stability = this.init_stability(Rating.Easy);\n  }\n\n  /**\n   * Updates the difficulty and stability values of the scheduling card based on the last difficulty,\n   * last stability, and the current retrievability.\n   * @param {SchedulingCard} s scheduling Card\n   * @param {number} last_d Difficulty\n   * @param {number} last_s Stability\n   * @param retrievability Retrievability\n   */\n  next_ds(\n    s: SchedulingCard,\n    last_d: number,\n    last_s: number,\n    retrievability: number,\n  ): void {\n    s.again.difficulty = this.next_difficulty(last_d, Rating.Again);\n    s.again.stability = this.next_forget_stability(\n      last_d,\n      last_s,\n      retrievability,\n    );\n    s.hard.difficulty = this.next_difficulty(last_d, Rating.Hard);\n    s.hard.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Hard,\n    );\n    s.good.difficulty = this.next_difficulty(last_d, Rating.Good);\n    s.good.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Good,\n    );\n    s.easy.difficulty = this.next_difficulty(last_d, Rating.Easy);\n    s.easy.stability = this.next_recall_stability(\n      last_d,\n      last_s,\n      retrievability,\n      Rating.Easy,\n    );\n  }\n\n  /**\n   * The formula used is :\n   * $$ S_0(G) = w_{G-1}$$\n   * $$S_0 = \\max \\lbrace S_0,0.1\\rbrace $$\n\n   * @param g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return Stability (interval when R=90%)\n   */\n  init_stability(g: Grade): number {\n    return Math.max(this.param.w[g - 1], 0.1);\n  }\n\n  /**\n   * The formula used is :\n   * $$D_0(G) = w_4 - (G-3) \\cdot w_5 $$\n   * $$D_0 = \\min \\lbrace \\max \\lbrace D_0(G),1 \\rbrace,10 \\rbrace$$\n   * where the $$D_0(3)=w_4$$ when the first rating is good.\n   *\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} Difficulty $$D \\in [1,10]$$\n   */\n  init_difficulty(g: Grade): number {\n    return +Math.min(\n      Math.max(this.param.w[4] - (g - 3) * this.param.w[5], 1),\n      10,\n    ).toFixed(8);\n  }\n\n  /**\n   * If fuzzing is disabled or ivl is less than 2.5, it returns the original interval.\n   * @param {number} ivl - The interval to be fuzzed.\n   * @param {number} elapsed_days t days since the last review\n   * @param {number} enable_fuzz - This adds a small random delay to the new interval time to prevent cards from sticking together and always being reviewed on the same day.\n   * @return {number} - The fuzzed interval.\n   **/\n  apply_fuzz(ivl: number, elapsed_days: number, enable_fuzz?: boolean): int {\n    if (!enable_fuzz || ivl < 2.5) return Math.round(ivl) as int;\n    const generator = pseudorandom(this.seed);\n    const fuzz_factor = generator();\n    const { min_ivl, max_ivl } = get_fuzz_range(\n      ivl,\n      elapsed_days,\n      this.param.maximum_interval,\n    );\n    return Math.floor(fuzz_factor * (max_ivl - min_ivl + 1) + min_ivl) as int;\n  }\n\n  /**\n   *   @see The formula used is : {@link FSRSAlgorithm.calculate_interval_modifier}\n   *   @param {number} s - Stability (interval when R=90%)\n   *   @param {number} elapsed_days t days since the last review\n   *   @param {number} enable_fuzz - This adds a small random delay to the new interval time to prevent cards from sticking together and always being reviewed on the same day.\n   */\n  next_interval(\n    s: number,\n    elapsed_days: number,\n    enable_fuzz: boolean = this.param.enable_fuzz,\n  ): int {\n    const newInterval = Math.min(\n      Math.max(1, Math.round(s * this.intervalModifier)),\n      this.param.maximum_interval,\n    ) as int;\n    return this.apply_fuzz(newInterval, elapsed_days, enable_fuzz);\n  }\n\n  /**\n   * The formula used is :\n   * $$\\text{next}_d = D - w_6 \\cdot (R - 2)$$\n   * $$D^\\prime(D,R) = w_5 \\cdot D_0(2) +(1 - w_5) \\cdot \\text{next}_d$$\n   * @param {number} d Difficulty $$D \\in [1,10]$$\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} $$\\text{next}_D$$\n   */\n  next_difficulty(d: number, g: Grade): number {\n    const next_d = d - this.param.w[6] * (g - 3);\n    return this.constrain_difficulty(\n      this.mean_reversion(this.param.w[4], next_d),\n    );\n  }\n\n  /**\n   * The formula used is :\n   * $$\\min \\lbrace \\max \\lbrace D_0,1 \\rbrace,10\\rbrace$$\n   * @param {number} difficulty $$D \\in [1,10]$$\n   */\n  constrain_difficulty(difficulty: number): number {\n    return Math.min(Math.max(+difficulty.toFixed(8), 1), 10);\n  }\n\n  /**\n   * The formula used is :\n   * $$w_7 \\cdot \\text{init} +(1 - w_7) \\cdot \\text{current}$$\n   * @param {number} init $$w_2 : D_0(3) = w_2 + (R-2) \\cdot w_3= w_2$$\n   * @param {number} current $$D - w_6 \\cdot (R - 2)$$\n   * @return {number} difficulty\n   */\n  mean_reversion(init: number, current: number): number {\n    return +(this.param.w[7] * init + (1 - this.param.w[7]) * current).toFixed(\n      8,\n    );\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_r(D,S,R,G) = S\\cdot(e^{w_8}\\cdot (11-D)\\cdot S^{-w_9}\\cdot(e^{w_{10}\\cdot(1-R)}-1)\\cdot w_{15}(\\text{if} G=2) \\cdot w_{16}(\\text{if} G=4)+1)$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   * @return {number} S^\\prime_r new stability after recall\n   */\n  next_recall_stability(d: number, s: number, r: number, g: Grade): number {\n    const hard_penalty = Rating.Hard === g ? this.param.w[15] : 1;\n    const easy_bound = Rating.Easy === g ? this.param.w[16] : 1;\n    return +(\n      s *\n      (1 +\n        Math.exp(this.param.w[8]) *\n          (11 - d) *\n          Math.pow(s, -this.param.w[9]) *\n          (Math.exp((1 - r) * this.param.w[10]) - 1) *\n          hard_penalty *\n          easy_bound)\n    ).toFixed(8);\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_f(D,S,R) = w_{11}\\cdot D^{-w_{12}}\\cdot ((S+1)^{w_{13}}-1) \\cdot e^{w_{14}\\cdot(1-R)}$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @return {number} S^\\prime_f new stability after forgetting\n   */\n  next_forget_stability(d: number, s: number, r: number): number {\n    return +(\n      this.param.w[11] *\n      Math.pow(d, -this.param.w[12]) *\n      (Math.pow(s + 1, this.param.w[13]) - 1) *\n      Math.exp((1 - r) * this.param.w[14])\n    ).toFixed(8);\n  }\n\n  /**\n   * The formula used is :\n   * $$R(t,S) = (1 + \\text{FACTOR} \\times \\frac{t}{9 \\cdot S})^{\\text{DECAY}}$$\n   * @param {number} elapsed_days t days since the last review\n   * @param {number} stability Stability (interval when R=90%)\n   * @return {number} r Retrievability (probability of recall)\n   */\n  forgetting_curve(elapsed_days: number, stability: number): number {\n    return +Math.pow(1 + (FACTOR * elapsed_days) / stability, DECAY).toFixed(8);\n  }\n}\n","import { SchedulingCard } from \"./scheduler\";\nimport { date_scheduler, fixDate, fixRating, fixState } from \"./help\";\nimport {\n  Card,\n  CardInput,\n  DateInput,\n  FSRSParameters,\n  Rating,\n  RecordLog,\n  RecordLogItem,\n  RescheduleOptions,\n  ReviewLog,\n  ReviewLogInput,\n  State,\n} from \"./models\";\nimport type { int } from \"./type\";\nimport { FSRSAlgorithm } from \"./algorithm\";\n\nexport class FSRS extends FSRSAlgorithm {\n  constructor(param: Partial<FSRSParameters>) {\n    super(param);\n  }\n\n  private preProcessCard(_card: CardInput | Card): Card {\n    return {\n      ..._card,\n      state: fixState(_card.state),\n      due: fixDate(_card.due),\n      last_review: _card.last_review ? fixDate(_card.last_review) : undefined,\n    };\n  }\n\n  private preProcessDate(_date: DateInput): Date {\n    return fixDate(_date);\n  }\n\n  private preProcessLog(_log: ReviewLogInput | ReviewLog): ReviewLog {\n    return {\n      ..._log,\n      due: fixDate(_log.due),\n      rating: fixRating(_log.rating),\n      state: fixState(_log.state),\n      review: fixDate(_log.review),\n    };\n  }\n\n  /**\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date());\n   * ```\n   * @example\n   * ```\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n   * function repeatAfterHandler(recordLog: RecordLog) {\n   *     const record: { [key in Grade]: RepeatRecordLog } = {} as {\n   *       [key in Grade]: RepeatRecordLog;\n   *     };\n   *     for (const grade of Grades) {\n   *       record[grade] = {\n   *         card: {\n   *           ...(recordLog[grade].card as Card & { cid: string }),\n   *           due: recordLog[grade].card.due.getTime(),\n   *           state: State[recordLog[grade].card.state] as StateType,\n   *           last_review: recordLog[grade].card.last_review\n   *             ? recordLog[grade].card.last_review!.getTime()\n   *             : null,\n   *         },\n   *         log: {\n   *           ...recordLog[grade].log,\n   *           cid: (recordLog[grade].card as Card & { cid: string }).cid,\n   *           due: recordLog[grade].log.due.getTime(),\n   *           review: recordLog[grade].log.review.getTime(),\n   *           state: State[recordLog[grade].log.state] as StateType,\n   *           rating: Rating[recordLog[grade].log.rating] as RatingType,\n   *         },\n   *       };\n   *     }\n   *     return record;\n   * }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date(), repeatAfterHandler);\n   * ```\n   */\n  repeat<R = RecordLog>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler?: (recordLog: RecordLog) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    const s = new SchedulingCard(processedCard, now).update_state(\n      processedCard.state,\n    );\n    this.seed = String(now.getTime()) + String(processedCard.reps);\n    let easy_interval, good_interval, hard_interval;\n    const interval = processedCard.elapsed_days;\n    switch (processedCard.state) {\n      case State.New:\n        this.init_ds(s);\n        s.again.due = now.scheduler(1 as int);\n        s.hard.due = now.scheduler(5 as int);\n        s.good.due = now.scheduler(10 as int);\n        easy_interval = this.next_interval(s.easy.stability, interval);\n        s.easy.scheduled_days = easy_interval;\n        s.easy.due = now.scheduler(easy_interval, true);\n        break;\n      case State.Learning:\n      case State.Relearning:\n        hard_interval = 0;\n        good_interval = this.next_interval(s.good.stability, interval);\n        easy_interval = Math.max(\n          this.next_interval(s.easy.stability, interval),\n          good_interval + 1,\n        );\n        s.schedule(now, hard_interval, good_interval, easy_interval);\n        break;\n      case State.Review: {\n        const last_d = processedCard.difficulty;\n        const last_s = processedCard.stability;\n        const retrievability = this.forgetting_curve(interval, last_s);\n        this.next_ds(s, last_d, last_s, retrievability);\n        hard_interval = this.next_interval(s.hard.stability, interval);\n        good_interval = this.next_interval(s.good.stability, interval);\n        hard_interval = Math.min(hard_interval, good_interval);\n        good_interval = Math.max(good_interval, hard_interval + 1);\n        easy_interval = Math.max(\n          this.next_interval(s.easy.stability, interval),\n          good_interval + 1,\n        );\n        s.schedule(now, hard_interval, good_interval, easy_interval);\n        break;\n      }\n    }\n    const recordLog = s.record_log(processedCard, now);\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(recordLog);\n    } else {\n      return recordLog as R;\n    }\n  }\n\n  /**\n   * Get the retrievability of the card\n   * @param card  Card to be processed\n   * @param now  Current time or scheduled time\n   * @param format  default:true , Convert the result to another type. (Optional)\n   * @returns  The retrievability of the card,if format is true, the result is a string, otherwise it is a number\n   */\n  get_retrievability<T extends boolean>(\n    card: CardInput | Card,\n    now: DateInput,\n    format: T = true as T,\n  ): undefined | (T extends true ? string : number) {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    if (processedCard.state !== State.Review) {\n      return undefined;\n    }\n    const t = Math.max(now.diff(processedCard.last_review as Date, \"days\"), 0);\n    const r = this.forgetting_curve(t, Math.round(processedCard.stability));\n    return (format ? `${(r * 100).toFixed(2)}%` : r) as T extends true\n      ? string\n      : number;\n  }\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param log last review log\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now);\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now);\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log);\n   * ```\n   *\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler);  //see method: createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log, cardAfterHandler);\n   * ```\n   */\n  rollback<R = Card>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler?: (prevCard: Card) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    const processedLog = this.preProcessLog(log);\n    if (processedLog.rating === Rating.Manual) {\n      throw new Error(\"Cannot rollback a manual rating\");\n    }\n    let last_due, last_review, last_lapses;\n    switch (processedLog.state) {\n      case State.New:\n        last_due = processedLog.due;\n        last_review = undefined;\n        last_lapses = 0;\n        break;\n      case State.Learning:\n      case State.Relearning:\n      case State.Review:\n        last_due = processedLog.review;\n        last_review = processedLog.due;\n        last_lapses =\n          processedCard.lapses -\n          (processedLog.rating === Rating.Again &&\n          processedLog.state === State.Review\n            ? 1\n            : 0);\n        break;\n    }\n\n    const prevCard: Card = {\n      ...processedCard,\n      due: last_due,\n      stability: processedLog.stability,\n      difficulty: processedLog.difficulty,\n      elapsed_days: processedLog.last_elapsed_days,\n      scheduled_days: processedLog.scheduled_days,\n      reps: Math.max(0, processedCard.reps - 1),\n      lapses: Math.max(0, last_lapses),\n      state: processedLog.state,\n      last_review: last_review,\n    };\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(prevCard);\n    } else {\n      return prevCard as R;\n    }\n  }\n\n  /**\n   *\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param reset_count Should the review count information(reps,lapses) be reset. (Optional)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCard = createEmptyCard(now);\n   * const scheduling_cards = f.repeat(emptyCard, now);\n   * const { card, log } = scheduling_cards[Rating.Hard];\n   * const forgetCard = f.forget(card, new Date(), true);\n   * ```\n   *\n   * @example\n   * ```\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked; //see method: fsrs.repeat()\n   * }\n   *\n   * function forgetAfterHandler(recordLogItem: RecordLogItem): RepeatRecordLog {\n   *     return {\n   *       card: {\n   *         ...(recordLogItem.card as Card & { cid: string }),\n   *         due: recordLogItem.card.due.getTime(),\n   *         state: State[recordLogItem.card.state] as StateType,\n   *         last_review: recordLogItem.card.last_review\n   *           ? recordLogItem.card.last_review!.getTime()\n   *           : null,\n   *       },\n   *       log: {\n   *         ...recordLogItem.log,\n   *         cid: (recordLogItem.card as Card & { cid: string }).cid,\n   *         due: recordLogItem.log.due.getTime(),\n   *         review: recordLogItem.log.review.getTime(),\n   *         state: State[recordLogItem.log.state] as StateType,\n   *         rating: Rating[recordLogItem.log.rating] as RatingType,\n   *       },\n   *     };\n   * }\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler); //see method:  createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card } = repeatFormAfterHandler[Rating.Hard];\n   * const forgetFromAfterHandler = f.forget(card, date_scheduler(now, 1, true), false, forgetAfterHandler);\n   * ```\n   */\n  forget<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean = false,\n    afterHandler?: (recordLogItem: RecordLogItem) => R,\n  ): R {\n    const processedCard = this.preProcessCard(card);\n    now = this.preProcessDate(now);\n    const scheduled_days =\n      processedCard.state === State.New\n        ? 0\n        : now.diff(processedCard.last_review as Date, \"days\");\n    const forget_log: ReviewLog = {\n      rating: Rating.Manual,\n      state: processedCard.state,\n      due: processedCard.due,\n      stability: processedCard.stability,\n      difficulty: processedCard.difficulty,\n      elapsed_days: 0,\n      last_elapsed_days: processedCard.elapsed_days,\n      scheduled_days: scheduled_days,\n      review: now,\n    };\n    const forget_card: Card = {\n      ...processedCard,\n      due: now,\n      stability: 0,\n      difficulty: 0,\n      elapsed_days: 0,\n      scheduled_days: 0,\n      reps: reset_count ? 0 : processedCard.reps,\n      lapses: reset_count ? 0 : processedCard.lapses,\n      state: State.New,\n      last_review: processedCard.last_review,\n    };\n    const recordLogItem: RecordLogItem = { card: forget_card, log: forget_log };\n    if (afterHandler && typeof afterHandler === \"function\") {\n      return afterHandler(recordLogItem);\n    } else {\n      return recordLogItem as R;\n    }\n  }\n\n  /**\n   *\n   * @param cards scheduled card collection\n   * @param options Reschedule options,fuzz is enabled by default.If the type of due is not Date, please implement dataHandler.\n   * @example\n   * ```typescript\n   * type CardType = Card & {\n   *     cid: number;\n   * };\n   * const reviewCard: CardType = {\n   *     cid: 1,\n   *     due: new Date(\"2024-03-17 04:43:02\"),\n   *     stability: 48.26139059062234,\n   *     difficulty: 5.67,\n   *     elapsed_days: 18,\n   *     scheduled_days: 51,\n   *     reps: 8,\n   *     lapses: 1,\n   *     state: State.Review,\n   *     last_review: new Date(\"2024-01-26 04:43:02\"),\n   * };\n   * const f = fsrs();\n   * const reschedule_cards = f.reschedule([reviewCard]);\n   * ```\n   *\n   */\n  reschedule<T extends CardInput | Card>(\n    cards: Array<T>,\n    options: RescheduleOptions = {},\n  ): Array<T> {\n    if (!Array.isArray(cards)) {\n      throw new Error(\"cards must be an array\");\n    }\n    const processedCard: T[] = [];\n    for (const card of cards) {\n      if (fixState(card.state) !== State.Review || !card.last_review) continue;\n      const scheduled_days = Math.floor(card.scheduled_days) as int;\n      const next_ivl = this.next_interval(\n        +card.stability.toFixed(2),\n        Math.round(card.elapsed_days),\n        options.enable_fuzz ?? true,\n      );\n      if (next_ivl === scheduled_days || next_ivl === 0) continue;\n\n      const processCard: T = { ...card };\n      processCard.scheduled_days = next_ivl;\n      const new_due = date_scheduler(processCard.last_review!, next_ivl, true);\n      if (options.dateHandler && typeof options.dateHandler === \"function\") {\n        processCard.due = options.dateHandler(new_due);\n      } else {\n        processCard.due = new_due;\n      }\n      processedCard.push(processCard);\n    }\n    return processedCard;\n  }\n}\n\n/**\n * Create a new instance of TS-FSRS\n * @param params FSRSParameters\n * @example\n * ```typescript\n * const f = fsrs();\n * ```\n * @example\n * ```typescript\n * const params: FSRSParameters = generatorParameters({ maximum_interval: 1000 });\n * const f = fsrs(params);\n * ```\n * @example\n * ```typescript\n * const f = fsrs({ maximum_interval: 1000 });\n * ```\n */\nexport const fsrs = (params?: Partial<FSRSParameters>) => {\n  return new FSRS(params || {});\n};\n"],"names":["State","t","Rating","isDay","date_scheduler","pre","unit","date_diff","formatDate","last_review","timeUnit","show_diff_message","now","fixDate","diff","r","dateInput","date","year","month","day","hours","minutes","seconds","padZero","num","TIMEUNIT","TIMEUNITFORMAT","due","i","value","timestamp","fixState","firstLetter","restOfString","ret","fixRating","Grades","FUZZ_RANGES","get_fuzz_range","interval","elapsed_days","maximum_interval","delta","range","min_ivl","max_ivl","SchedulingCard","card","state","hard_interval","good_interval","easy_interval","default_request_retention","default_maximum_interval","default_w","default_enable_fuzz","FSRSVersion","generatorParameters","props","createEmptyCard","afterHandler","emptyCard","DECAY","FACTOR","FSRSAlgorithm","params","request_retention","_this","target","prop","_params","key","paramKey","s","last_d","last_s","retrievability","g","ivl","enable_fuzz","fuzz_factor","pseudorandom","newInterval","d","next_d","difficulty","init","current","hard_penalty","easy_bound","stability","FSRS","param","_card","_date","_log","processedCard","recordLog","format","log","processedLog","last_due","last_lapses","prevCard","reset_count","scheduled_days","forget_log","recordLogItem","cards","options","next_ivl","processCard","new_due","fsrs"],"mappings":"0BAEO,IAAKA,GAAAA,IACVA,EAAAA,EAAA,IAAM,CAAN,EAAA,MACAA,IAAA,SAAW,CAAA,EAAX,WACAA,EAAAC,EAAA,OAAS,GAAT,SACAD,EAAAA,EAAA,WAAa,CAAb,EAAA,aAJUA,IAAAA,GASA,CAAA,CAAA,EAAAE,GAAAA,IACVA,EAAAA,EAAA,OAAS,CAAT,EAAA,SACAA,IAAA,MAAQ,CAAA,EAAR,QACAA,EAAA,EAAA,KAAO,GAAP,OACAA,EAAAA,EAAA,KAAO,CAAP,EAAA,OACAA,IAAA,KAAO,CAAA,EAAP,OALUA,IAAAA,GAAA,CAAA,CAAA,ECKZ,KAAK,UAAU,UAAY,SAAUD,EAAQE,EAAuB,CAClE,OAAOC,EAAe,KAAMH,EAAGE,CAAK,CACtC,EAOA,KAAK,UAAU,KAAO,SAAUE,EAAWC,EAAiB,CAC1D,OAAOC,EAAU,KAAMF,EAAKC,CAAI,CAClC,EAEA,KAAK,UAAU,OAAS,UAAoB,CAC1C,OAAOE,EAAW,IAAI,CACxB,EAEA,KAAK,UAAU,UAAY,SACzBC,EACAH,EACAI,EACA,CACA,OAAOC,EAAkB,KAAMF,EAAaH,EAAMI,CAAQ,CAC5D,WASgBN,EACdQ,EACAX,EACAE,EACM,CACN,OAAO,IAAI,KACTA,EACIU,EAAQD,CAAG,EAAE,QAAQ,EAAIX,EAAI,GAAK,GAAK,GAAK,IAC5CY,EAAQD,CAAG,EAAE,QAAA,EAAYX,EAAI,GAAK,GACxC,CACF,CAEO,SAASM,EAAUK,EAAgBP,EAAgBC,EAAoB,CAC5E,GAAI,CAACM,GAAO,CAACP,EACX,MAAM,IAAI,MAAM,cAAc,EAEhC,MAAMS,EAAOD,EAAQD,CAAG,EAAE,QAAY,EAAAC,EAAQR,CAAG,EAAE,QACnD,EAAA,IAAIU,EAAI,EACR,OAAQT,EACN,CAAA,IAAK,OACHS,EAAI,KAAK,MAAMD,GAAQ,GAAK,GAAK,GAAK,IAAK,EAC3C,MACF,IAAK,UACHC,EAAI,KAAK,MAAMD,GAAQ,GAAK,IAAK,EACjC,KACJ,CACA,OAAOC,CACT,CAEO,SAASP,EAAWQ,EAA8B,CACvD,MAAMC,EAAOJ,EAAQG,CAAS,EACxBE,EAAeD,EAAK,cACpBE,EAAgBF,EAAK,SAAS,EAAI,EAClCG,EAAcH,EAAK,UACnBI,EAAgBJ,EAAK,SAAS,EAC9BK,EAAkBL,EAAK,WAAA,EACvBM,EAAkBN,EAAK,WAAW,EAExC,MAAO,GAAGC,CAAI,IAAIM,EAAQL,CAAK,CAAC,IAAIK,EAAQJ,CAAG,CAAC,IAAII,EAAQH,CAAK,CAAC,IAAIG,EACpEF,CACF,CAAC,IAAIE,EAAQD,CAAO,CAAC,EACvB,CAEA,SAASC,EAAQC,EAAqB,CACpC,OAAOA,EAAM,GAAK,IAAIA,CAAG,GAAK,GAAGA,CAAG,EACtC,CAEA,MAAMC,EAAW,CAAC,GAAI,GAAI,GAAI,GAAI,EAAE,EAC9BC,EAAiB,CAAC,SAAU,MAAO,OAAQ,MAAO,QAAS,MAAM,EAEvD,SAAAhB,EACdiB,EACAnB,EACAH,EACAI,EAAqBiB,EACb,CACRC,EAAMf,EAAQe,CAAG,EACjBnB,EAAcI,EAAQJ,CAAW,EAC7BC,EAAS,SAAWiB,EAAe,SACrCjB,EAAWiB,GAEb,IAAIb,EAAOc,EAAI,QAAA,EAAYnB,EAAY,QACnC,EAAAoB,EAEJ,IADAf,GAAQ,IACHe,EAAI,EAAGA,EAAIH,EAAS,QACnB,EAAAZ,EAAOY,EAASG,CAAC,GADUA,IAI7Bf,GAAQY,EAASG,CAAC,EAGtB,MAAO,GAAG,KAAK,MAAMf,CAAI,CAAC,GAAGR,EAAOI,EAASmB,CAAC,EAAI,EAAE,EACtD,CAEO,SAAShB,EAAQiB,EAAgB,CACtC,GAAI,OAAOA,GAAU,UAAYA,aAAiB,KAChD,OAAOA,EACF,GAAI,OAAOA,GAAU,SAAU,CACpC,MAAMC,EAAY,KAAK,MAAMD,CAAK,EAClC,GAAK,MAAMC,CAAS,EAGlB,MAAM,IAAI,MAAM,iBAAiBD,CAAK,GAAG,EAFzC,OAAO,IAAI,KAAKC,CAAS,CAI7B,SAAW,OAAOD,GAAU,SAC1B,OAAO,IAAI,KAAKA,CAAK,EAEvB,MAAM,IAAI,MAAM,iBAAiBA,CAAK,GAAG,CAC3C,CAEgB,SAAAE,EAASF,EAAuB,CAC9C,GAAI,OAAOA,GAAU,SAAU,CAC7B,MAAMG,EAAcH,EAAM,OAAO,CAAC,EAAE,YAAA,EAC9BI,EAAeJ,EAAM,MAAM,CAAC,EAAE,YAC9BK,EAAAA,EAAMnC,EAAM,GAAGiC,CAAW,GAAGC,CAAY,EAAwB,EACvE,GAAIC,IAAQ,OACV,MAAM,IAAI,MAAM,kBAAkBL,CAAK,GAAG,EAE5C,OAAOK,CACT,SAAW,OAAOL,GAAU,SAC1B,OAAOA,EAET,MAAM,IAAI,MAAM,kBAAkBA,CAAK,GAAG,CAC5C,UAEgBM,EAAUN,EAAwB,CAChD,GAAI,OAAOA,GAAU,SAAU,CAC7B,MAAMG,EAAcH,EAAM,OAAO,CAAC,EAAE,YAAY,EAC1CI,EAAeJ,EAAM,MAAM,CAAC,EAAE,YAAY,EAC1CK,EAAMjC,EAAO,GAAG+B,CAAW,GAAGC,CAAY,EAAyB,EACzE,GAAIC,IAAQ,OACV,MAAM,IAAI,MAAM,mBAAmBL,CAAK,GAAG,EAE7C,OAAOK,CACT,SAAW,OAAOL,GAAU,SAC1B,OAAOA,EAET,MAAM,IAAI,MAAM,mBAAmBA,CAAK,GAAG,CAC7C,CAEO,MAAMO,EAA4B,CACvCnC,EAAO,MACPA,EAAO,KACPA,EAAO,KACPA,EAAO,IACT,EAEMoC,EAAc,CAClB,CACE,MAAO,IACP,IAAK,EACL,OAAQ,GACV,EACA,CACE,MAAO,EACP,IAAK,GACL,OAAQ,EACV,EACA,CACE,MAAO,GACP,IAAK,IACL,OAAQ,GACV,CACF,WAEgBC,EACdC,EACAC,EACAC,EACA,CACA,IAAIC,EAAQ,EACZ,UAAWC,KAASN,EAClBK,GACEC,EAAM,OAAS,KAAK,IAAI,KAAK,IAAIJ,EAAUI,EAAM,GAAG,EAAIA,EAAM,MAAO,CAAG,EAE5EJ,EAAW,KAAK,IAAIA,EAAUE,CAAgB,EAC9C,IAAIG,EAAU,KAAK,IAAI,EAAG,KAAK,MAAML,EAAWG,CAAK,CAAC,EACtD,MAAMG,EAAU,KAAK,IAAI,KAAK,MAAMN,EAAWG,CAAK,EAAGD,CAAgB,EACvE,OAAIF,EAAWC,IACbI,EAAU,KAAK,IAAIA,EAASJ,EAAe,CAAC,GAE9CI,EAAU,KAAK,IAAIA,EAASC,CAAO,EAC5B,CAAE,QAAAD,EAAS,QAAAC,CAAQ,CAC5B,CChNO,MAAMC,CAAe,CAC1B,MACA,KACA,KACA,KACA,YACA,kBAEQ,KAAKC,EAAkB,CAC7B,MAAO,CACL,GAAGA,CACL,CACF,CAEA,YAAYA,EAAYpC,EAAW,CACjC,KAAK,YAAcoC,EAAK,aAAeA,EAAK,IAC5C,KAAK,kBAAoBA,EAAK,aAC9BA,EAAK,aACHA,EAAK,QAAUhD,EAAM,IAAM,EAAIY,EAAI,KAAKoC,EAAK,YAAqB,MAAM,EAC1EA,EAAK,YAAcpC,EACnBoC,EAAK,MAAQ,EACb,KAAK,MAAQ,KAAK,KAAKA,CAAI,EAC3B,KAAK,KAAO,KAAK,KAAKA,CAAI,EAC1B,KAAK,KAAO,KAAK,KAAKA,CAAI,EAC1B,KAAK,KAAO,KAAK,KAAKA,CAAI,CAC5B,CAEA,aAAaC,EAAc,CACzB,OAAIA,IAAUjD,EAAM,KAClB,KAAK,MAAM,MAAQA,EAAM,SACzB,KAAK,KAAK,MAAQA,EAAM,SACxB,KAAK,KAAK,MAAQA,EAAM,SACxB,KAAK,KAAK,MAAQA,EAAM,QACfiD,IAAUjD,EAAM,UAAYiD,IAAUjD,EAAM,YACrD,KAAK,MAAM,MAAQiD,EACnB,KAAK,KAAK,MAAQA,EAClB,KAAK,KAAK,MAAQjD,EAAM,OACxB,KAAK,KAAK,MAAQA,EAAM,QACfiD,IAAUjD,EAAM,SACzB,KAAK,MAAM,MAAQA,EAAM,WACzB,KAAK,KAAK,MAAQA,EAAM,OACxB,KAAK,KAAK,MAAQA,EAAM,OACxB,KAAK,KAAK,MAAQA,EAAM,OACxB,KAAK,MAAM,QAAU,GAEhB,IACT,CAEA,SACEY,EACAsC,EACAC,EACAC,EACgB,CAChB,OAAK,KAAA,MAAM,eAAiB,EAC5B,KAAK,KAAK,eAAiBF,EAC3B,KAAK,KAAK,eAAiBC,EAC3B,KAAK,KAAK,eAAiBC,EAC3B,KAAK,MAAM,IAAMhD,EAAeQ,EAAK,CAAC,EACtC,KAAK,KAAK,IACRsC,EAAgB,EACZ9C,EAAeQ,EAAKsC,EAAe,EAAI,EACvC9C,EAAeQ,EAAK,EAAE,EAC5B,KAAK,KAAK,IAAMR,EAAeQ,EAAKuC,EAAe,EAAI,EACvD,KAAK,KAAK,IAAM/C,EAAeQ,EAAKwC,EAAe,EAAI,EAChD,IACT,CAEA,WAAWJ,EAAYpC,EAAsB,CAC3C,MAAO,CACL,CAACV,EAAO,KAAK,EAAG,CACd,KAAM,KAAK,MACX,IAAK,CACH,OAAQA,EAAO,MACf,MAAO8C,EAAK,MACZ,IAAK,KAAK,YACV,UAAWA,EAAK,UAChB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,kBAAmB,KAAK,kBACxB,eAAgBA,EAAK,eACrB,OAAQpC,CACV,CACF,EACA,CAACV,EAAO,IAAI,EAAG,CACb,KAAM,KAAK,KACX,IAAK,CACH,OAAQA,EAAO,KACf,MAAO8C,EAAK,MACZ,IAAK,KAAK,YACV,UAAWA,EAAK,UAChB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,kBAAmB,KAAK,kBACxB,eAAgBA,EAAK,eACrB,OAAQpC,CACV,CACF,EACA,CAACV,EAAO,IAAI,EAAG,CACb,KAAM,KAAK,KACX,IAAK,CACH,OAAQA,EAAO,KACf,MAAO8C,EAAK,MACZ,IAAK,KAAK,YACV,UAAWA,EAAK,UAChB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,kBAAmB,KAAK,kBACxB,eAAgBA,EAAK,eACrB,OAAQpC,CACV,CACF,EACA,CAACV,EAAO,IAAI,EAAG,CACb,KAAM,KAAK,KACX,IAAK,CACH,OAAQA,EAAO,KACf,MAAO8C,EAAK,MACZ,IAAK,KAAK,YACV,UAAWA,EAAK,UAChB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,kBAAmB,KAAK,kBACxB,eAAgBA,EAAK,eACrB,OAAQpC,CACV,CACF,CACF,CACF,CACF,CChIa,MAAAyC,EAA4B,GAC5BC,EAA2B,MAC3BC,EAAY,CACvB,MAAQ,OAAQ,OAAQ,QAAS,OAAQ,OAAQ,MAAQ,MAAQ,MACjE,MAAQ,OAAQ,OAAQ,MAAQ,MAAQ,OAAQ,KAAO,MACzD,EACaC,EAAsB,GAEtBC,EAAsB,QAEtBC,EACXC,IAEO,CACL,mBAAmBA,GAAA,KAAAA,OAAAA,EAAO,oBAAqBN,EAC/C,kBAAkBM,GAAA,KAAA,OAAAA,EAAO,mBAAoBL,EAC7C,GAAGK,GAAA,KAAAA,OAAAA,EAAO,IAAKJ,EACf,aAAaI,GAAA,KAAAA,OAAAA,EAAO,cAAeH,CACrC,GAiCK,SAASI,EACdhD,EACAiD,EACG,CACH,MAAMC,EAAkB,CACtB,IAAKlD,EAAMC,EAAQD,CAAG,EAAI,IAAI,KAC9B,UAAW,EACX,WAAY,EACZ,aAAc,EACd,eAAgB,EAChB,KAAM,EACN,OAAQ,EACR,MAAOZ,EAAM,IACb,YAAa,MACf,EACA,OAAI6D,GAAgB,OAAOA,GAAiB,WACnCA,EAAaC,CAAS,EAEtBA,CAEX,CChEO,MAAMC,EAAgB,IAOhBC,EAAiB,GAAK,SAKtBC,CAAc,CACf,MACA,iBACA,KAEV,YAAYC,EAAiC,CAC3C,KAAK,MAAQ,IAAI,MACfR,EAAoBQ,CAAM,EAC1B,KAAK,qBACP,CAAA,EACA,KAAK,iBAAmB,KAAK,4BAC3B,KAAK,MAAM,iBACb,CACF,CAEA,IAAI,mBAA4B,CAC9B,OAAO,KAAK,gBACd,CASA,4BAA4BC,EAAmC,CAC7D,GAAIA,GAAqB,GAAKA,EAAoB,EAChD,MAAM,IAAI,MAAM,uDAAuD,EAEzE,MAAO,GAAG,KAAK,IAAIA,EAAmB,EAAIJ,CAAK,EAAI,GAAKC,GAAQ,QAAQ,CAAC,CAC3E,CAKA,IAAI,YAA6B,CAC/B,OAAO,KAAK,KACd,CAMA,IAAI,WAAWE,EAAiC,CAC9C,KAAK,kBAAkBA,CAAM,CAC/B,CAEQ,sBAAqD,CAE3D,MAAME,EAAuB,KAC7B,MAAO,CACL,IAAK,SAAUC,EAAQC,EAAMxC,EAAO,CAClC,OAAIwC,IAAS,qBAAuB,OAAO,SAASxC,CAAK,IACvDsC,EAAM,iBAAmBA,EAAM,4BAC7B,OAAOtC,CAAK,CACd,GAGFuC,EAAOC,CAAI,EAAIxC,EACR,EACT,CACF,CACF,CAEQ,kBAAkBoC,EAAuC,CAC/D,MAAMK,EAAUb,EAAoBQ,CAAM,EAC1C,UAAWM,KAAOD,EAChB,GAAIC,KAAO,KAAK,MAAO,CACrB,MAAMC,EAAWD,EACjB,KAAK,MAAMC,CAAQ,EAAIF,EAAQE,CAAQ,CACzC,CAEJ,CAEA,QAAQC,EAAyB,CAC/BA,EAAE,MAAM,WAAa,KAAK,gBAAgBxE,EAAO,KAAK,EACtDwE,EAAE,MAAM,UAAY,KAAK,eAAexE,EAAO,KAAK,EACpDwE,EAAE,KAAK,WAAa,KAAK,gBAAgBxE,EAAO,IAAI,EACpDwE,EAAE,KAAK,UAAY,KAAK,eAAexE,EAAO,IAAI,EAClDwE,EAAE,KAAK,WAAa,KAAK,gBAAgBxE,EAAO,IAAI,EACpDwE,EAAE,KAAK,UAAY,KAAK,eAAexE,EAAO,IAAI,EAClDwE,EAAE,KAAK,WAAa,KAAK,gBAAgBxE,EAAO,IAAI,EACpDwE,EAAE,KAAK,UAAY,KAAK,eAAexE,EAAO,IAAI,CACpD,CAUA,QACEwE,EACAC,EACAC,EACAC,EACM,CACNH,EAAE,MAAM,WAAa,KAAK,gBAAgBC,EAAQzE,EAAO,KAAK,EAC9DwE,EAAE,MAAM,UAAY,KAAK,sBACvBC,EACAC,EACAC,CACF,EACAH,EAAE,KAAK,WAAa,KAAK,gBAAgBC,EAAQzE,EAAO,IAAI,EAC5DwE,EAAE,KAAK,UAAY,KAAK,sBACtBC,EACAC,EACAC,EACA3E,EAAO,IACT,EACAwE,EAAE,KAAK,WAAa,KAAK,gBAAgBC,EAAQzE,EAAO,IAAI,EAC5DwE,EAAE,KAAK,UAAY,KAAK,sBACtBC,EACAC,EACAC,EACA3E,EAAO,IACT,EACAwE,EAAE,KAAK,WAAa,KAAK,gBAAgBC,EAAQzE,EAAO,IAAI,EAC5DwE,EAAE,KAAK,UAAY,KAAK,sBACtBC,EACAC,EACAC,EACA3E,EAAO,IACT,CACF,CAUA,eAAe4E,EAAkB,CAC/B,OAAO,KAAK,IAAI,KAAK,MAAM,EAAEA,EAAI,CAAC,EAAG,EAAG,CAC1C,CAWA,gBAAgBA,EAAkB,CAChC,MAAO,CAAC,KAAK,IACX,KAAK,IAAI,KAAK,MAAM,EAAE,CAAC,GAAKA,EAAI,GAAK,KAAK,MAAM,EAAE,CAAC,EAAG,CAAC,EACvD,EACF,EAAE,QAAQ,CAAC,CACb,CASA,WAAWC,EAAatC,EAAsBuC,EAA4B,CACxE,GAAI,CAACA,GAAeD,EAAM,IAAK,OAAO,KAAK,MAAMA,CAAG,EAEpD,MAAME,EADYC,EAAa,KAAK,IAAI,EACV,EACxB,CAAE,QAAArC,EAAS,QAAAC,CAAQ,EAAIP,EAC3BwC,EACAtC,EACA,KAAK,MAAM,gBACb,EACA,OAAO,KAAK,MAAMwC,GAAenC,EAAUD,EAAU,GAAKA,CAAO,CACnE,CAQA,cACE6B,EACAjC,EACAuC,EAAuB,KAAK,MAAM,YAC7B,CACL,MAAMG,EAAc,KAAK,IACvB,KAAK,IAAI,EAAG,KAAK,MAAMT,EAAI,KAAK,gBAAgB,CAAC,EACjD,KAAK,MAAM,gBACb,EACA,OAAO,KAAK,WAAWS,EAAa1C,EAAcuC,CAAW,CAC/D,CAUA,gBAAgBI,EAAWN,EAAkB,CAC3C,MAAMO,EAASD,EAAI,KAAK,MAAM,EAAE,CAAC,GAAKN,EAAI,GAC1C,OAAO,KAAK,qBACV,KAAK,eAAe,KAAK,MAAM,EAAE,CAAC,EAAGO,CAAM,CAC7C,CACF,CAOA,qBAAqBC,EAA4B,CAC/C,OAAO,KAAK,IAAI,KAAK,IAAI,CAACA,EAAW,QAAQ,CAAC,EAAG,CAAC,EAAG,EAAE,CACzD,CASA,eAAeC,EAAcC,EAAyB,CACpD,MAAO,EAAE,KAAK,MAAM,EAAE,CAAC,EAAID,GAAQ,EAAI,KAAK,MAAM,EAAE,CAAC,GAAKC,GAAS,QACjE,CACF,CACF,CAWA,sBAAsBJ,EAAWV,EAAW,EAAWI,EAAkB,CACvE,MAAMW,EAAevF,EAAO,OAAS4E,EAAI,KAAK,MAAM,EAAE,EAAE,EAAI,EACtDY,EAAaxF,EAAO,OAAS4E,EAAI,KAAK,MAAM,EAAE,EAAE,EAAI,EAC1D,MAAO,EACLJ,GACC,EACC,KAAK,IAAI,KAAK,MAAM,EAAE,CAAC,CAAC,GACrB,GAAKU,GACN,KAAK,IAAIV,EAAG,CAAC,KAAK,MAAM,EAAE,CAAC,CAAC,GAC3B,KAAK,KAAK,EAAI,GAAK,KAAK,MAAM,EAAE,EAAE,CAAC,EAAI,GACxCe,EACAC,IACJ,QAAQ,CAAC,CACb,CAUA,sBAAsBN,EAAWV,EAAW,EAAmB,CAC7D,MAAO,EACL,KAAK,MAAM,EAAE,EAAE,EACf,KAAK,IAAIU,EAAG,CAAC,KAAK,MAAM,EAAE,EAAE,CAAC,GAC5B,KAAK,IAAIV,EAAI,EAAG,KAAK,MAAM,EAAE,EAAE,CAAC,EAAI,GACrC,KAAK,KAAK,EAAI,GAAK,KAAK,MAAM,EAAE,EAAE,CAAC,GACnC,QAAQ,CAAC,CACb,CASA,iBAAiBjC,EAAsBkD,EAA2B,CAChE,MAAO,CAAC,KAAK,IAAI,EAAK3B,EAASvB,EAAgBkD,EAAW5B,CAAK,EAAE,QAAQ,CAAC,CAC5E,CACF,CC9Ra,MAAA6B,UAAa3B,CAAc,CACtC,YAAY4B,EAAgC,CAC1C,MAAMA,CAAK,CACb,CAEQ,eAAeC,EAA+B,CACpD,MAAO,CACL,GAAGA,EACH,MAAO9D,EAAS8D,EAAM,KAAK,EAC3B,IAAKjF,EAAQiF,EAAM,GAAG,EACtB,YAAaA,EAAM,YAAcjF,EAAQiF,EAAM,WAAW,EAAI,MAChE,CACF,CAEQ,eAAeC,EAAwB,CAC7C,OAAOlF,EAAQkF,CAAK,CACtB,CAEQ,cAAcC,EAA6C,CACjE,MAAO,CACL,GAAGA,EACH,IAAKnF,EAAQmF,EAAK,GAAG,EACrB,OAAQ5D,EAAU4D,EAAK,MAAM,EAC7B,MAAOhE,EAASgE,EAAK,KAAK,EAC1B,OAAQnF,EAAQmF,EAAK,MAAM,CAC7B,CACF,CA2DA,OACEhD,EACApC,EACAiD,EACG,CACH,MAAMoC,EAAgB,KAAK,eAAejD,CAAI,EAC9CpC,EAAM,KAAK,eAAeA,CAAG,EAC7B,MAAM8D,EAAI,IAAI3B,EAAekD,EAAerF,CAAG,EAAE,aAC/CqF,EAAc,KAChB,EACA,KAAK,KAAO,OAAOrF,EAAI,QAAS,CAAA,EAAI,OAAOqF,EAAc,IAAI,EAC7D,IAAI7C,EAAeD,EAAeD,EAClC,MAAMV,EAAWyD,EAAc,aAC/B,OAAQA,EAAc,OACpB,KAAKjG,EAAM,IACT,KAAK,QAAQ0E,CAAC,EACdA,EAAE,MAAM,IAAM9D,EAAI,UAAU,CAAQ,EACpC8D,EAAE,KAAK,IAAM9D,EAAI,UAAU,CAAQ,EACnC8D,EAAE,KAAK,IAAM9D,EAAI,UAAU,EAAS,EACpCwC,EAAgB,KAAK,cAAcsB,EAAE,KAAK,UAAWlC,CAAQ,EAC7DkC,EAAE,KAAK,eAAiBtB,EACxBsB,EAAE,KAAK,IAAM9D,EAAI,UAAUwC,EAAe,EAAI,EAC9C,MACF,KAAKpD,EAAM,SACX,KAAKA,EAAM,WACTkD,EAAgB,EAChBC,EAAgB,KAAK,cAAcuB,EAAE,KAAK,UAAWlC,CAAQ,EAC7DY,EAAgB,KAAK,IACnB,KAAK,cAAcsB,EAAE,KAAK,UAAWlC,CAAQ,EAC7CW,EAAgB,CAClB,EACAuB,EAAE,SAAS9D,EAAKsC,EAAeC,EAAeC,CAAa,EAC3D,MACF,KAAKpD,EAAM,OAAQ,CACjB,MAAM2E,EAASsB,EAAc,WACvBrB,EAASqB,EAAc,UACvBpB,EAAiB,KAAK,iBAAiBrC,EAAUoC,CAAM,EAC7D,KAAK,QAAQF,EAAGC,EAAQC,EAAQC,CAAc,EAC9C3B,EAAgB,KAAK,cAAcwB,EAAE,KAAK,UAAWlC,CAAQ,EAC7DW,EAAgB,KAAK,cAAcuB,EAAE,KAAK,UAAWlC,CAAQ,EAC7DU,EAAgB,KAAK,IAAIA,EAAeC,CAAa,EACrDA,EAAgB,KAAK,IAAIA,EAAeD,EAAgB,CAAC,EACzDE,EAAgB,KAAK,IACnB,KAAK,cAAcsB,EAAE,KAAK,UAAWlC,CAAQ,EAC7CW,EAAgB,CAClB,EACAuB,EAAE,SAAS9D,EAAKsC,EAAeC,EAAeC,CAAa,EAC3D,KACF,CACF,CACA,MAAM8C,EAAYxB,EAAE,WAAWuB,EAAerF,CAAG,EACjD,OAAIiD,GAAgB,OAAOA,GAAiB,WACnCA,EAAaqC,CAAS,EAEtBA,CAEX,CASA,mBACElD,EACApC,EACAuF,EAAY,GACoC,CAChD,MAAMF,EAAgB,KAAK,eAAejD,CAAI,EAE9C,GADApC,EAAM,KAAK,eAAeA,CAAG,EACzBqF,EAAc,QAAUjG,EAAM,OAChC,OAEF,MAAMC,EAAI,KAAK,IAAIW,EAAI,KAAKqF,EAAc,YAAqB,MAAM,EAAG,CAAC,EACnElF,EAAI,KAAK,iBAAiBd,EAAG,KAAK,MAAMgG,EAAc,SAAS,CAAC,EACtE,OAAQE,EAAS,IAAIpF,EAAI,KAAK,QAAQ,CAAC,CAAC,IAAMA,CAGhD,CA2BA,SACEiC,EACAoD,EACAvC,EACG,CACH,MAAMoC,EAAgB,KAAK,eAAejD,CAAI,EACxCqD,EAAe,KAAK,cAAcD,CAAG,EAC3C,GAAIC,EAAa,SAAWnG,EAAO,OACjC,MAAM,IAAI,MAAM,iCAAiC,EAEnD,IAAIoG,EAAU7F,EAAa8F,EAC3B,OAAQF,EAAa,MAAA,CACnB,KAAKrG,EAAM,IACTsG,EAAWD,EAAa,IACxB5F,EAAc,OACd8F,EAAc,EACd,MACF,KAAKvG,EAAM,SACX,KAAKA,EAAM,WACX,KAAKA,EAAM,OACTsG,EAAWD,EAAa,OACxB5F,EAAc4F,EAAa,IAC3BE,EACEN,EAAc,QACbI,EAAa,SAAWnG,EAAO,OAChCmG,EAAa,QAAUrG,EAAM,OACzB,EACA,GACN,KACJ,CAEA,MAAMwG,EAAiB,CACrB,GAAGP,EACH,IAAKK,EACL,UAAWD,EAAa,UACxB,WAAYA,EAAa,WACzB,aAAcA,EAAa,kBAC3B,eAAgBA,EAAa,eAC7B,KAAM,KAAK,IAAI,EAAGJ,EAAc,KAAO,CAAC,EACxC,OAAQ,KAAK,IAAI,EAAGM,CAAW,EAC/B,MAAOF,EAAa,MACpB,YAAa5F,CACf,EACA,OAAIoD,GAAgB,OAAOA,GAAiB,WACnCA,EAAa2C,CAAQ,EAErBA,CAEX,CAqDA,OACExD,EACApC,EACA6F,EAAuB,GACvB5C,EACG,CACH,MAAMoC,EAAgB,KAAK,eAAejD,CAAI,EAC9CpC,EAAM,KAAK,eAAeA,CAAG,EAC7B,MAAM8F,EACJT,EAAc,QAAUjG,EAAM,IAC1B,EACAY,EAAI,KAAKqF,EAAc,YAAqB,MAAM,EAClDU,EAAwB,CAC5B,OAAQzG,EAAO,OACf,MAAO+F,EAAc,MACrB,IAAKA,EAAc,IACnB,UAAWA,EAAc,UACzB,WAAYA,EAAc,WAC1B,aAAc,EACd,kBAAmBA,EAAc,aACjC,eAAgBS,EAChB,OAAQ9F,CACV,EAaMgG,EAA+B,CAAE,KAZb,CACxB,GAAGX,EACH,IAAKrF,EACL,UAAW,EACX,WAAY,EACZ,aAAc,EACd,eAAgB,EAChB,KAAM6F,EAAc,EAAIR,EAAc,KACtC,OAAQQ,EAAc,EAAIR,EAAc,OACxC,MAAOjG,EAAM,IACb,YAAaiG,EAAc,WAC7B,EAC0D,IAAKU,CAAW,EAC1E,OAAI9C,GAAgB,OAAOA,GAAiB,WACnCA,EAAa+C,CAAa,EAE1BA,CAEX,CA4BA,WACEC,EACAC,EAA6B,GACnB,CACV,GAAI,CAAC,MAAM,QAAQD,CAAK,EACtB,MAAM,IAAI,MAAM,wBAAwB,EAE1C,MAAMZ,EAAqB,GAC3B,UAAWjD,KAAQ6D,EAAO,CACxB,GAAI7E,EAASgB,EAAK,KAAK,IAAMhD,EAAM,QAAU,CAACgD,EAAK,YAAa,SAChE,MAAM0D,EAAiB,KAAK,MAAM1D,EAAK,cAAc,EAC/C+D,EAAW,KAAK,cACpB,CAAC/D,EAAK,UAAU,QAAQ,CAAC,EACzB,KAAK,MAAMA,EAAK,YAAY,EAC5B8D,EAAQ,aAAe,EACzB,EACA,GAAIC,IAAaL,GAAkBK,IAAa,EAAG,SAEnD,MAAMC,EAAiB,CAAE,GAAGhE,CAAK,EACjCgE,EAAY,eAAiBD,EAC7B,MAAME,EAAU7G,EAAe4G,EAAY,YAAcD,EAAU,EAAI,EACnED,EAAQ,aAAe,OAAOA,EAAQ,aAAgB,WACxDE,EAAY,IAAMF,EAAQ,YAAYG,CAAO,EAE7CD,EAAY,IAAMC,EAEpBhB,EAAc,KAAKe,CAAW,CAChC,CACA,OAAOf,CACT,CACF,OAmBaiB,EAAQhD,GACZ,IAAI0B,EAAK1B,GAAU,CAAE,CAAA"}